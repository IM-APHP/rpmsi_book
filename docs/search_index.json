[["index.html", "Analyser les données PMSI avec R Bienvenu", " Analyser les données PMSI avec R Rémi Flicoteaux Bienvenu Les premiers chapitres du livre sont une compiltation/traduction de livres numériques que nous vous conseillons de lire pour aller plus loin : R for Data Science Advanced R Traitement des données PMSI avec R "],["introduction.html", "1 Introduction 1.1 Les notions et concepts que vous aller acquérir", " 1 Introduction R est un langage de programmation ce qui signifie quil est une interface entre des instructions données par un utilisateur, dans une forme écrite, et les capacités de calcul de lordinateur. Ces capacités sont très grandes dès lors que les instructions qui lui sont données peuvent être exécutées sans erreur, et cest bien lart de la programmation qui est de réussir à utiliser ces fonctionnalités sans erreur. Lidée qui sous tend la création des langages tels que R est de simplifier le plus possible ces interactions, de façon à simplifier la vie des utilisateurs. Linformatique peut permettre de résoudre de nombreux problèmes et R est un langage spécialisé dans le calcul statistique. Ces dernières années, la perception de cette discipline a beaucoup évolué et en particulier avec lavènement dune vision peut être plus globale que le calcul statistique lui-même, celle de la science des données, qui inclut également de nombreuses étapes de traitement et préparation des données elles-mêmes et qui sont un préalable au calcul à proprement parler. R a suivi ces évolutions avec le développement de package spécifiques qui sont venus enrichir larchitecture de base du langage et qui proposent une nouvelle façon décrire le code très influencée par lidée que chaque projet est en fait lexécution de tâches élémentaires successives qui senchaînent sous la forme dune chaîne de traitement. Nous allons voir dans les premiers chapitres de ce livre les éléments de base du langage et comment ces nouvelles méthodes de programmation peuvent être particulièrement adaptées à lanalyse des données PMSI. Cette introduction à la programmation en R qui se veut la plus pragmatique possible, est exclusivement orienté vers lanalyse des données PMSI de façon à faire de R un de vos outils de travail directement opérationnel. Elle ne doit pas faire perdre de vue que toute personne qui souhaitera à lissue de cette introduction sengager dans lutilisation de R sur le long terme, devra approfondir sa connaissance du langage afin de devenir complètement autonome. La chance est quil existe 2 ouvrages de références qui vont permettront dacquérir ces compétences : - R for Data Science - Advanced R La lecture de ces livres nous apparaît indispensable et loin dêtre insurmontable au contraire. Cette introduction à R a pour objectif de vous donner lenvie daller plus loin. 1.1 Les notions et concepts que vous aller acquérir R est un language de programmation, ce qui veut dire que vous allez faire de la programmation. Que cela ninquiètes pas trop ceux qui nen ont pas lhabitude, cest au final assez simple. R est un langage de programmation, ce qui veut dire que vous allez faire de la programmation. Que cela ninquiète pas trop ceux qui nen ont pas lhabitude, cest au final assez simple. On peut classiquement séparer en 4 les étapes dun projet danalyse des données PMSI : 1- Importer les données. Pour nous cela repose essentiellement par lutilisation du package pmeasyr, qui permet dimporter les fichiers officiels en entrée et sortie du logiciel GENRSA et qui sont donc utilisés par les établissements pour la transmission des données à lATIH. Il est souvent nécessaire pour bien exploiter les données PMSI dutiliser des référentiels (CIM, CCAM, GHM,). La plupart des référentiels utiles sont regroupés dans le package referime.Néanmoins dautres types de données peuvent vous êtes utiles et nous couvrirons également le sujets de limport des données dans dautres format. 2- Préparer et transformer des données brute afin par exemple de créer de nouvelle variables qui nous permettent de répondre aux questions posées. 3- Lanalyse de données elles-mêmes. Dans le cadre des projets PMSI cest souvent la sélections de séjours et la réalisation de statistiques descriptives. Certains projets plus complexes nécessitent de faire de la modélisation. 4- Enfin, nous avons besoin de communiquer des résultats sous forme de données tabulées et de représentations graphiques. Ce livre a pour objectif de vous donner les bases qui vous permettrons de réaliser ces 4 étapes. "],["language-r-les-fondamentaux.html", "2 Language R : les fondamentaux 2.1 Instructions 2.2 Objets 2.3 Fonctions 2.4 Le format des objets 2.5 La grammaire dplyr", " 2 Language R : les fondamentaux 2.1 Instructions R en tant que langage interprété (en opposition à un langage compilé) peut être utilisé pour envoyer des instructions qui sont exécutées directement par la machine. Il existe donc un interpréteur R que lon peut utiliser tel quel, par exemple comme une machine à calculer. 1 / 200 * 30 ## [1] 0.15 (59 + 73 + 2) / 3 ## [1] 44.66667 sin(pi / 2) ## [1] 1 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 Dès lors que nos instructions vont se complexifier on voit quil sera utile de garder la trace de nos actions et cest la raison pour laquelle R sutilise avec un éditeur de code qui permet de sauvegarder lensemble des instructions données à la machine. Celles-ci pourront ensuite être envoyées en une seule fois, voire sexécuter automatiquement avec lutilisation dun planificateur de tâches. RStudio propose un environnement de travail intégré qui permet de réunir ces 2 fonctions principales : interpréteur et éditeur de code. Cette intégration permet denvoyer simplement le code écrit dans léditeur à linterpréteur. Cest cette dernière façon décrire du code que nous allons utiliser et qui va nous permettre dutiliser les programmes préparés pour cette introduction. 2.2 Objets En complément de lexécution dinstruction, R permet de stocker des données dans la mémoire de lordinateur. Pour cela R, nutilise que la mémoire RAM, la mémoire de travail. Ce principe permet de garantir une exécution rapide des instructions qui utilise les données enregistrées en mémoire, à linverse il sagit dune mémoire dont la taille est limitée et qui rend donc lutilisation du langage R plus complexe pour le traitement de données volumineuses. Dans le cadre du traitement des données PMSI, nous pourrons utiliser un autre mode denregistrement des données que nous décrirons plus loin dans le livre. En R, toute donnée stockée en mémoire est appelée un objet. Tous les objets ont 2 caractéristiques : un nom qui permet de les retrouver simplement un type qui permet de structurer la façon dont les données sont stockées. Il existe plusieurs types dobjets en R dont la définition et la formalisation informatique constituent le cur du langage. Cela peut être des nombres, des données plus complexes rangées dans des vecteurs ou des tableaux de données (datadrame) qui sont un équivalent de feuille de calcul excel avec des lignes et des colonnes, mais aussi des instructions, organisées dans une fonction. Il existe dautres types dobjets qui permettent de donner au langage puissance et souplesse. Parmi eux, nous mentionnons les listes qui sont très pratique et qui sont une collection dobjets qui peuvent avoir des types différents rangés une même entité. On peut créer de nouveaux objets avec linstruction &lt;-: x &lt;- 3 * 4 x ## [1] 12 Toutes les instructions (statements) qui permettent de créer des objets (assignment statements) sont de la forme : nom_objet &lt;- value Le signe = fonctionne également, mais il est quelque peu trompeur et il est communément admis que pour bien marqué le fait quil sagit de donner un nom à un objet stocké en mémoire, on préfère utiliser &lt;- . 2.3 Fonctions Lensemble du langage R tient donc sur ce paradigme de nom et de type dobjets et sur le fait que les objets sont accessibles par leur nom. Les fonctions constituent un type dobjets à part. Dans la mesure où, en règle générale, elles reçoivent des arguments sur lesquels on va appliquer des transformations, elle sappelle avec des parenthèses. function_name(arg1 = val1, arg2 = val2, ...) Il nen reste pas moins quelles sont des objets, stockées en mémoire, accessibles à tout moment par leur nom, lorsquelles sont appelées, elles réalisent lensemble des instructions quelles contiennent et renvoie leur résultat. mean(x) Les fonctions de base dont dispose le langage R sont organisées sous forme de packages. En règle générale, elles ne sont accessibles par leur nom que si nous avons demandé le chargement du package. Ce chargement a pour conséquence de placer dans lenvironnement de travail le nom de lensemble des fonctions dun package. Le package qui contient le langage lui-même sappelle base. Il est en grande partie constituée de fonctions écrites en C qui constituent lapport du langage lui-même. Il est par défaut chargé en mémoire et les fonctions du package peuvent donc être utilisées sans chargement préalable comme nous lavons vu avec lexemple du calcul de la moyenne. Les fonctions des différents packages peuvent néanmoins être appelées directement dès lors que lon référence dans lappel le nom du package : pmeasyr::irsa(p) Cette fonction du package pmeasyr permet de réalisé limport des RSA dans R. Avant de réaliser concrètement cet import, voyons plus en détails comment s organise lenregistrement des données. 2.4 Le format des objets Chaque donnée possède un format de base qui permet de stocker linformation. R distingue 5 types de données : caractère entiers nombre (réel ou décimal) les nombres complexes une variable logique oui/non Il en existe en réalité une 6ème forme qui ne sera pas abordée ici. Avec ces différentes formes on peut constuituer dautres types de données unitaires en particulier : les dates et datatime qui sont en réalité stockées sous forme numérique qui constue lécart par rapport à un référentiel (par exemple le nombre de jour qui sépare la date du jour du 1er janvier 1970) les facteurs Nous approfondirons ces différentes types au cours du livre. Le niveau suivant le vecteur qui correspond vraiment au cur du langage. Linstruction : permet de créer facilement des séquences : x&lt;- 1:10 Ils sont bien sur constitués par un ensemble de données élémentaires dun certain type. Un vecteur nest donc constitué que dun seul type de données. Cela permet en particulier de garantir que des opération numérique pourront être réalisée dun bloc sur un vecteur, par exemple une addition : x+5 ## [1] 6 7 8 9 10 11 12 13 14 15 On voit que le chiffre 5 a été ajouté à lensemble des éléments du vecteur en une seule instruction. Le calcul est vectorisé cest ce qui fait la grande force de R et qui assure à la fois une simplicité décriture (pas de boucle à écrire) et une rapidité dexécution (lensemble du détail du calcul a été programmé en C avec le maximum defficacité). En fait, le niveau de base des objets R sont des vecteurs de données élémentaires et il nexiste pas à proprement parler dobjet vecteur dont on pourrait tester le type. Nous indiquons des fonctions qui permettent davoir dobtenir des information sur la nature des objets. str(x) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 class(x) ## [1] &quot;integer&quot; typeof(x) ## [1] &quot;integer&quot; La taille du vecteur : length(x) ## [1] 10 Ces vecteurs peuvent ensuite être associé en tableau de données (dataframe) qui seront les éléments les plus utilisés pour lanalyse de données PMSI. x &lt;- data.frame(x= 1:10, y= 21:30) Il sagit en fait dune collection de vecteurs. str(x) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: int 1 2 3 4 5 6 7 8 9 10 ## $ y: int 21 22 23 24 25 26 27 28 29 30 class(x) ## [1] &quot;data.frame&quot; typeof(x) ## [1] &quot;list&quot; Les données de base unitaires sont accessibles par lutilisation des crochets en identifiants les coordonnées dans le tableau, position de ligne et de colonne : line_number = 1 columun_number = 2 x[line_number , columun_number] ## [1] 21 Les dataframe ont des noms de colonnes et des noms de ligne names(x) ## [1] &quot;x&quot; &quot;y&quot; row.names(x) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; Les données de base unitaires sont également accessibles en identifiant les noms de lignes et de colonnes qui sont de type caractère et non numérique : line_name = &quot;1&quot; columun_name = &quot;x&quot; x[line_name , columun_name] ## [1] 1 Enfin, on peut également identifier une colonne entière par lutilisation du symbole $. x$x ## [1] 1 2 3 4 5 6 7 8 9 10 Comme un dataframe est une collection de vecteur, les colonnes des dataframes partagent les mêmes caractéristiques, et en particulier elles ne sont constituées que dune seule catégorie de données. On peut par ailleurs utiliser le calcul vectoriel : x$x + 5 ## [1] 6 7 8 9 10 11 12 13 14 15 On pourrait développer les nombreuses actions qui peuvent réalisée avec les dataframe dans le paradigme historique du langage R. Nous allons néamoins faire un saut pour se concentrer directement sur les nouvelles méthodes de manipulation des objets en R dans le paradigme tidyverse qui propose un ensemble de packages permettant de faciliter lanalyse de données. 2.5 La grammaire dplyr En premier lieu, nous introduisons une fontion particulière qui a pour but de tenir compte du fait que lon doit en pratique rarement nutiliser quune seule instruction, et qua linverse on enchaine les instructions sur un même objet, qui se transforme à chaque étape. Cette opérateur qui va vous sembler atypique au premier abord, va rapidement devenir votre meilleur ami. Il a été introduit dans le package magrittr, chargeons le dans lenvironement de travail de façon à `%&gt;%` &lt;- magrittr::`%&gt;%` Lopérateur pipe permet donc denchainter les instructions, ci dessous deux instruction équivalentes : x + 5 -3 ## x y ## 1 3 23 ## 2 4 24 ## 3 5 25 ## 4 6 26 ## 5 7 27 ## 6 8 28 ## 7 9 29 ## 8 10 30 ## 9 11 31 ## 10 12 32 x %&gt;% + 5 %&gt;% -3 ## x y ## 1 3 23 ## 2 4 24 ## 3 5 25 ## 4 6 26 ## 5 7 27 ## 6 8 28 ## 7 9 29 ## 8 10 30 ## 9 11 31 ## 10 12 32 Le second élément, est la conceptualisation, proposée par le package dplyr, des différentes étapes clés de lanalyse de données dans un paradigme qui ressemble au langage sql et que vous connaissez peut être. Ces principales étapes sont : select : pour sélectionner les colonnes des dataframes filter : pour filtrer les données mutate : qui nexiste pas en sql, et qui permet de modifier les colonnes dun dataframe. join : pour réaliser les jointures entre dataframe group_by : pour réaliser des regroupements summarise: qui permet de faire des comptes sur lensemble des données, par exemple compter le nombre de lignes, cette calculs tenant compte des différents niveau déclarés dans le group_by. Pour tester ces différentes fonction, commençons par charger des données PMSI avec le package pmeasyr. "],["premiers-pas-avec-les-données-pmsi-importées-avec-pmeasyr.html", "3 Premiers pas avec les données PMSI importées avec pmeasyr 3.1 Import des données MCO 3.2 Premières analyses", " 3 Premiers pas avec les données PMSI importées avec pmeasyr 3.1 Import des données MCO La première étape de choisir un répertoire de travail et denregistrer vos fichiers de remontées dans ce répertoire. Nosu prendrons ici les recommandations de Guillaume : '~/Documents/data/mco . Les noms des fichiers en sortie de GENRSA sont de la forme : finess.annee.mois.date_et_heure_de_creation.in.zip finess.annee.mois.date_et_heure_de_creation.out.zip Ensuite on dézippe larchive avec la fonction adzip : pmeasyr::adezip(finess = 750712184, annee = 2021, mois = 8, path = &#39;C:/Users/3056269/Documents/data/mco&#39;, liste = c(&quot;rss&quot;), type = &quot;in&quot;) Import des rsa : pmeasyr::irum(finess = 750712184, annee = 2021, mois = 8, path = &#39;C:/Users/3056269/Documents/data/mco&#39;, typi = 4, tolower_names = TRUE ) -&gt; rum21 Limport a créé plusiseurs dataframe qui sont rangé dans lobjet rsa21 qui est une liste : typeof(rum21) names(rum21) 3.2 Premières analyses Dans cette première partie nous allons tester différents calcul sur les RSA avec le formalisme de dplyr. Commençons par charger le package de façon à ne pas avoir à repéter le préfix dplyr:: : library(dplyr) Sélectionner les rum dont le diagnostic est I10 : rum21$rum %&gt;% filter(dp == &quot;I10&quot;) Sélectionner les rum dont le diagnostic est I10 et changer le format de la date pour avoir le mois de sortie. rum21$rum %&gt;% filter(dp == &quot;I10&quot;) %&gt;% mutate(moissor = format(d8soue,&quot;%m&quot;) ) On peut donc changer le format dune date en R avec la fonction format. Ci dessus les principaux type de format utilisés. Sélectionner les rum dont le diagnostic est I10 et compter le nombre de résumé par mois, fonction n() permet de compte le nombre de ligne dans le tableau de données, ici groupé par mois : rum21$rum %&gt;% filter(dp == &quot;I10&quot;) %&gt;% mutate(moissor = format(d8soue,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = n()) Créer une table qui permette davoir la date dentrée et de sortie du séjour : dates_sejours &lt;- rum21$rum %&gt;% group_by(nas) %&gt;% summarise(dtentr = min(d8eeue), dtsor = max(d8soue)) %&gt;% ungroup() dates_sejours Réaliser la jointure entre les RUM et les dates dentrée/sortie du séjours pour faire un calcul du nombre de RUM par mois de sortie du séjour : rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot;) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = n()) Par défaut, la jointure est réalisée sur les colonnes qui sont présentes dans les 2 dataframes : Ne compter que les séjours et non les RUM : rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot;) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = length(unique(nas))) Rechercher le diagnostic dans lensemble des diagnostics : 1) Rechercher le diagnostic dans les diagnostics associés rum21$das %&gt;% dplyr::filter(das == &quot;I10&quot;) -&gt; das_i10 utiliser ce résultat pour compléter la recherche rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot; | nas %in% das_i10$nas ) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = length(unique(nas))) Faire la même recherche pour les patients qui résident à Paris : rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot; | nas %in% das_i10$nas, substr(cdresi,1,2) == &quot;75&quot; ) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = length(unique(nas))) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
