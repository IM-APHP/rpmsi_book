[["index.html", "Analyser les données PMSI avec R Bienvenu", " Analyser les données PMSI avec R Rémi Flicoteaux Bienvenu Les premiers chapitres du livre sont une compiltation/traduction de livres numériques que nous vous conseillons de lire pour aller plus loin : R for Data Science Advanced R Traitement des données PMSI avec R "],["introduction.html", "1 Introduction 1.1 Les notions et concepts que vous aller acquérir", " 1 Introduction R est un langage de programmation ce qui signifie quil est une interface entre des instructions données par un utilisateur, dans une forme écrite, et les capacités de calcul de lordinateur. Ces capacités sont très grandes dès lors que les instructions qui lui sont données peuvent être exécutées sans erreur, et cest bien lart de la programmation qui est de réussir à utiliser ces fonctionnalités sans erreur. Lidée qui sous tend la création des langages tels que R est de simplifier le plus possible ces interactions, de façon à simplifier la vie des utilisateurs. Linformatique peut permettre de résoudre de nombreux problèmes et R est un langage spécialisé dans le calcul statistique. Ces dernières années, la perception de cette discipline a beaucoup évolué et en particulier avec lavènement dune vision peut être plus globale que le calcul statistique lui-même, celle de la science des données, qui inclut également de nombreuses étapes de traitement et préparation des données elles-mêmes et qui sont un préalable au calcul à proprement parler. R a suivi ces évolutions avec le développement de package spécifiques qui sont venus enrichir larchitecture de base du langage et qui proposent une nouvelle façon décrire le code très influencée par lidée que chaque projet est en fait lexécution de tâches élémentaires successives qui senchaînent sous la forme dune chaîne de traitement. Nous allons voir dans les premiers chapitres de ce livre les éléments de base du langage et comment ces nouvelles méthodes de programmation peuvent être particulièrement adaptées à lanalyse des données PMSI. Cette introduction à la programmation en R qui se veut la plus pragmatique possible, est exclusivement orienté vers lanalyse des données PMSI de façon à faire de R un de vos outils de travail directement opérationnel. Elle ne doit pas faire perdre de vue que toute personne qui souhaitera à lissue de cette introduction sengager dans lutilisation de R sur le long terme, devra approfondir sa connaissance du langage afin de devenir complètement autonome. La chance est quil existe 2 ouvrages de références qui vont permettront dacquérir ces compétences : - R for Data Science - Advanced R La lecture de ces livres nous apparaît indispensable et loin dêtre insurmontable au contraire. Cette introduction à R a pour objectif de vous donner lenvie daller plus loin. 1.1 Les notions et concepts que vous aller acquérir R est un language de programmation, ce qui veut dire que vous allez faire de la programmation. Que cela ninquiètes pas trop ceux qui nen ont pas lhabitude, cest au final assez simple. R est un langage de programmation, ce qui veut dire que vous allez faire de la programmation. Que cela ninquiète pas trop ceux qui nen ont pas lhabitude, cest au final assez simple. On peut classiquement séparer en 4 les étapes dun projet danalyse des données PMSI : 1- Importer les données. Pour nous cela repose essentiellement par lutilisation du package pmeasyr, qui permet dimporter les fichiers officiels en entrée et sortie du logiciel GENRSA et qui sont donc utilisés par les établissements pour la transmission des données à lATIH. Il est souvent nécessaire pour bien exploiter les données PMSI dutiliser des référentiels (CIM, CCAM, GHM,). La plupart des référentiels utiles sont regroupés dans le package referime.Néanmoins dautres types de données peuvent vous êtes utiles et nous couvrirons également le sujets de limport des données dans dautres format. 2- Préparer et transformer des données brute afin par exemple de créer de nouvelle variables qui nous permettent de répondre aux questions posées. 3- Lanalyse de données elles-mêmes. Dans le cadre des projets PMSI cest souvent la sélections de séjours et la réalisation de statistiques descriptives. Certains projets plus complexes nécessitent de faire de la modélisation. 4- Enfin, nous avons besoin de communiquer des résultats sous forme de données tabulées et de représentations graphiques. Ce livre a pour objectif de vous donner les bases qui vous permettrons de réaliser ces 4 étapes. "],["language-r-les-fondamentaux.html", "2 Language R : les fondamentaux 2.1 Instructions 2.2 Objets 2.3 Fonctions 2.4 Le format des objets 2.5 La grammaire dplyr", " 2 Language R : les fondamentaux 2.1 Instructions R en tant que langage interprété (en opposition à un langage compilé) peut être utilisé pour envoyer des instructions qui sont exécutées directement par la machine. Il existe donc un interpréteur R que lon peut utiliser tel quel, par exemple comme une machine à calculer. 1 / 200 * 30 ## [1] 0.15 (59 + 73 + 2) / 3 ## [1] 44.66667 sin(pi / 2) ## [1] 1 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 Dès lors que nos instructions vont se complexifier on voit quil sera utile de garder la trace de nos actions et cest la raison pour laquelle R sutilise avec un éditeur de code qui permet de sauvegarder lensemble des instructions données à la machine. Celles-ci pourront ensuite être envoyées en une seule fois, voire sexécuter automatiquement avec lutilisation dun planificateur de tâches. RStudio propose un environnement de travail intégré qui permet de réunir ces 2 fonctions principales : interpréteur et éditeur de code. Cette intégration permet denvoyer simplement le code écrit dans léditeur à linterpréteur. Cest cette dernière façon décrire du code que nous allons utiliser et qui va nous permettre dutiliser les programmes préparés pour cette introduction. 2.2 Objets En complément de lexécution dinstruction, R permet de stocker des données dans la mémoire de lordinateur. Pour cela R, nutilise que la mémoire RAM, la mémoire de travail. Ce principe permet de garantir une exécution rapide des instructions qui utilise les données enregistrées en mémoire, à linverse il sagit dune mémoire dont la taille est limitée et qui rend donc lutilisation du langage R plus complexe pour le traitement de données volumineuses. Dans le cadre du traitement des données PMSI, nous pourrons utiliser un autre mode denregistrement des données que nous décrirons plus loin dans le livre. En R, toute donnée stockée en mémoire est appelée un objet. Tous les objets ont 2 caractéristiques : un nom qui permet de les retrouver simplement un type qui permet de structurer la façon dont les données sont stockées. Il existe plusieurs types dobjets en R dont la définition et la formalisation informatique constituent le cur du langage. Cela peut être des nombres, des données plus complexes rangées dans des vecteurs ou des tableaux de données (datadrame) qui sont un équivalent de feuille de calcul excel avec des lignes et des colonnes, mais aussi des instructions, organisées dans une fonction. Il existe dautres types dobjets qui permettent de donner au langage puissance et souplesse. Parmi eux, nous mentionnons les listes qui sont très pratique et qui sont une collection dobjets qui peuvent avoir des types différents rangés une même entité. On peut créer de nouveaux objets avec linstruction &lt;-: x &lt;- 3 * 4 x ## [1] 12 Toutes les instructions (statements) qui permettent de créer des objets (assignment statements) sont de la forme : nom_objet &lt;- value Le signe = fonctionne également, mais il est quelque peu trompeur et il est communément admis que pour bien marqué le fait quil sagit de donner un nom à un objet stocké en mémoire, on préfère utiliser &lt;- . 2.3 Fonctions Lensemble du langage R tient donc sur ce paradigme de nom et de type dobjets et sur le fait que les objets sont accessibles par leur nom. Les fonctions constituent un type dobjets à part. Dans la mesure où, en règle générale, elles reçoivent des arguments sur lesquels on va appliquer des transformations, elle sappelle avec des parenthèses. function_name(arg1 = val1, arg2 = val2, ...) Il nen reste pas moins quelles sont des objets, stockées en mémoire, accessibles à tout moment par leur nom, lorsquelles sont appelées, elles réalisent lensemble des instructions quelles contiennent et renvoie leur résultat. mean(x) Les fonctions de base dont dispose le langage R sont organisées sous forme de packages. En règle générale, elles ne sont accessibles par leur nom que si nous avons demandé le chargement du package. Ce chargement a pour conséquence de placer dans lenvironnement de travail le nom de lensemble des fonctions dun package. Le package qui contient le langage lui-même sappelle base. Il est en grande partie constituée de fonctions écrites en C qui constituent lapport du langage lui-même. Il est par défaut chargé en mémoire et les fonctions du package peuvent donc être utilisées sans chargement préalable comme nous lavons vu avec lexemple du calcul de la moyenne. Les fonctions des différents packages peuvent néanmoins être appelées directement dès lors que lon référence dans lappel le nom du package : pmeasyr::irsa(p) Cette fonction du package pmeasyr permet de réalisé limport des RSA dans R. Avant de réaliser concrètement cet import, voyons plus en détails comment s organise lenregistrement des données. 2.4 Le format des objets Chaque donnée possède un format de base qui permet de stocker linformation. R distingue 5 types de données : caractère entiers nombre (réel ou décimal) les nombres complexes une variable logique oui/non Il en existe en réalité une 6ème forme qui ne sera pas abordée ici. Avec ces différentes formes on peut constuituer dautres types de données unitaires en particulier : les dates et datatime qui sont en réalité stockées sous forme numérique qui constue lécart par rapport à un référentiel (par exemple le nombre de jour qui sépare la date du jour du 1er janvier 1970) les facteurs Nous approfondirons ces différentes types au cours du livre. Le niveau suivant le vecteur qui correspond vraiment au cur du langage. Linstruction : permet de créer facilement des séquences : x&lt;- 1:10 Ils sont bien sur constitués par un ensemble de données élémentaires dun certain type. Un vecteur nest donc constitué que dun seul type de données. Cela permet en particulier de garantir que des opération numérique pourront être réalisée dun bloc sur un vecteur, par exemple une addition : x+5 ## [1] 6 7 8 9 10 11 12 13 14 15 On voit que le chiffre 5 a été ajouté à lensemble des éléments du vecteur en une seule instruction. Le calcul est vectorisé cest ce qui fait la grande force de R et qui assure à la fois une simplicité décriture (pas de boucle à écrire) et une rapidité dexécution (lensemble du détail du calcul a été programmé en C avec le maximum defficacité). En fait, le niveau de base des objets R sont des vecteurs de données élémentaires et il nexiste pas à proprement parler dobjet vecteur dont on pourrait tester le type. Nous indiquons des fonctions qui permettent davoir dobtenir des information sur la nature des objets. str(x) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 class(x) ## [1] &quot;integer&quot; typeof(x) ## [1] &quot;integer&quot; La taille du vecteur : length(x) ## [1] 10 Ces vecteurs peuvent ensuite être associé en tableau de données (dataframe) qui seront les éléments les plus utilisés pour lanalyse de données PMSI. x &lt;- data.frame(x= 1:10, y= 21:30) Il sagit en fait dune collection de vecteurs. str(x) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: int 1 2 3 4 5 6 7 8 9 10 ## $ y: int 21 22 23 24 25 26 27 28 29 30 class(x) ## [1] &quot;data.frame&quot; typeof(x) ## [1] &quot;list&quot; Les données de base unitaires sont accessibles par lutilisation des crochets en identifiants les coordonnées dans le tableau, position de ligne et de colonne : line_number = 1 columun_number = 2 x[line_number , columun_number] ## [1] 21 Les dataframe ont des noms de colonnes et des noms de ligne names(x) ## [1] &quot;x&quot; &quot;y&quot; row.names(x) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; Les données de base unitaires sont également accessibles en identifiant les noms de lignes et de colonnes qui sont de type caractère et non numérique : line_name = &quot;1&quot; columun_name = &quot;x&quot; x[line_name , columun_name] ## [1] 1 Enfin, on peut également identifier une colonne entière par lutilisation du symbole $. x$x ## [1] 1 2 3 4 5 6 7 8 9 10 Comme un dataframe est une collection de vecteur, les colonnes des dataframes partagent les mêmes caractéristiques, et en particulier elles ne sont constituées que dune seule catégorie de données. On peut par ailleurs utiliser le calcul vectoriel : x$x + 5 ## [1] 6 7 8 9 10 11 12 13 14 15 On pourrait développer les nombreuses actions qui peuvent réalisée avec les dataframe dans le paradigme historique du langage R. Nous allons néamoins faire un saut pour se concentrer directement sur les nouvelles méthodes de manipulation des objets en R dans le paradigme tidyverse qui propose un ensemble de packages permettant de faciliter lanalyse de données. 2.5 La grammaire dplyr En premier lieu, nous introduisons une fontion particulière qui a pour but de tenir compte du fait que lon doit en pratique rarement nutiliser quune seule instruction, et qua linverse on enchaine les instructions sur un même objet, qui se transforme à chaque étape. Cette opérateur qui va vous sembler atypique au premier abord, va rapidement devenir votre meilleur ami. Il a été introduit dans le package magrittr, chargeons le dans lenvironement de travail de façon à `%&gt;%` &lt;- magrittr::`%&gt;%` Lopérateur pipe permet donc denchainter les instructions, ci dessous deux instruction équivalentes : x + 5 -3 ## x y ## 1 3 23 ## 2 4 24 ## 3 5 25 ## 4 6 26 ## 5 7 27 ## 6 8 28 ## 7 9 29 ## 8 10 30 ## 9 11 31 ## 10 12 32 x %&gt;% + 5 %&gt;% -3 ## x y ## 1 3 23 ## 2 4 24 ## 3 5 25 ## 4 6 26 ## 5 7 27 ## 6 8 28 ## 7 9 29 ## 8 10 30 ## 9 11 31 ## 10 12 32 Le second élément, est la conceptualisation, proposée par le package dplyr, des différentes étapes clés de lanalyse de données dans un paradigme qui ressemble au langage sql et que vous connaissez peut être. Ces principales étapes sont : select : pour sélectionner les colonnes des dataframes filter : pour filtrer les données mutate : qui nexiste pas en sql, et qui permet de modifier les colonnes dun dataframe. join : pour réaliser les jointures entre dataframe group_by : pour réaliser des regroupements summarise: qui permet de faire des comptes sur lensemble des données, par exemple compter le nombre de lignes, cette calculs tenant compte des différents niveau déclarés dans le group_by. Pour tester ces différentes fonction, commençons par charger des données PMSI avec le package pmeasyr. "],["premiers-pas-avec-les-données-pmsi-importées-avec-pmeasyr.html", "3 Premiers pas avec les données PMSI importées avec pmeasyr 3.1 Import des données MCO 3.2 Premières analyses", " 3 Premiers pas avec les données PMSI importées avec pmeasyr 3.1 Import des données MCO La première étape de choisir un répertoire de travail et denregistrer vos fichiers de remontées dans ce répertoire. Nosu prendrons ici les recommandations de Guillaume : '~/Documents/data/mco . Les noms des fichiers en sortie de GENRSA sont de la forme : finess.annee.mois.date_et_heure_de_creation.in.zip finess.annee.mois.date_et_heure_de_creation.out.zip Ensuite on dézippe larchive avec la fonction adzip : pmeasyr::adezip(finess = 750712184, annee = 2021, mois = 8, path = &#39;C:/Users/3056269/Documents/data/mco&#39;, liste = c(&quot;rss&quot;), type = &quot;in&quot;) Import des rsa : pmeasyr::irum(finess = 750712184, annee = 2021, mois = 8, path = &#39;C:/Users/3056269/Documents/data/mco&#39;, typi = 4, tolower_names = TRUE ) -&gt; rum21 Limport a créé plusiseurs dataframe qui sont rangé dans lobjet rsa21 qui est une liste : typeof(rum21) names(rum21) 3.2 Premières analyses Dans cette première partie nous allons tester différents calcul sur les RSA avec le formalisme de dplyr. Commençons par charger le package de façon à ne pas avoir à repéter le préfix dplyr:: : library(dplyr) Sélectionner les rum dont le diagnostic est I10 : rum21$rum %&gt;% filter(dp == &quot;I10&quot;) Sélectionner les rum dont le diagnostic est I10 et changer le format de la date pour avoir le mois de sortie. rum21$rum %&gt;% filter(dp == &quot;I10&quot;) %&gt;% mutate(moissor = format(d8soue,&quot;%m&quot;) ) On peut donc changer le format dune date en R avec la fonction format. Ci dessus les principaux type de format utilisés. Sélectionner les rum dont le diagnostic est I10 et compter le nombre de résumé par mois, fonction n() permet de compte le nombre de ligne dans le tableau de données, ici groupé par mois : rum21$rum %&gt;% filter(dp == &quot;I10&quot;) %&gt;% mutate(moissor = format(d8soue,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = n()) Créer une table qui permette davoir la date dentrée et de sortie du séjour : dates_sejours &lt;- rum21$rum %&gt;% group_by(nas) %&gt;% summarise(dtentr = min(d8eeue), dtsor = max(d8soue)) %&gt;% ungroup() dates_sejours Réaliser la jointure entre les RUM et les dates dentrée/sortie du séjours pour faire un calcul du nombre de RUM par mois de sortie du séjour : rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot;) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = n()) Par défaut, la jointure est réalisée sur les colonnes qui sont présentes dans les 2 dataframes : Ne compter que les séjours et non les RUM : rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot;) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = length(unique(nas))) Rechercher le diagnostic dans lensemble des diagnostics : 1) Rechercher le diagnostic dans les diagnostics associés rum21$das %&gt;% dplyr::filter(das == &quot;I10&quot;) -&gt; das_i10 utiliser ce résultat pour compléter la recherche rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot; | nas %in% das_i10$nas ) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = length(unique(nas))) Faire la même recherche pour les patients qui résident à Paris : rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot; | nas %in% das_i10$nas, substr(cdresi,1,2) == &quot;75&quot; ) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = length(unique(nas))) "],["pmeasyr-imports-mco.html", "4 pmeasyr : Imports MCO 4.1 Les différents fichiers à importer 4.2 Noyau pmeasyr 4.3 Imports des RSA 4.4 Import des RUM 4.5 Import des fichiers TRA et ANO 4.6 Table pmeasyr des formats 4.7 Création dune table contenant la plus part des informations utiles", " 4 pmeasyr : Imports MCO 4.1 Les différents fichiers à importer Nom Fonction irsa ~ MCO - Import des RSA irum ~ MCO - Import des RUM idiap ~ MCO - Import des DIAP idmi_mco ~ MCO - Import des DMI iium ~ MCO - Import des donnees UM ileg_mco ~ MCO - Import des erreurs Leg imed_mco ~ MCO - Import des Med ipo ~ MCO - Import des PO iano_mco ~ MCO - Import des Anohosp Source : pmeasyr-book 4.2 Noyau pmeasyr Comme les différents paramètres permettant à pmeasyr de réaliser limport (et en particulier de retrouver le bon fichier zipper sur le disque) sont réutilisés plusieurs fois, nous pouvons créer un objet pmeasyr destiné à stocker toutes ces informarions, appelé, noyau : path_data = &#39;path/to/your/data/folder&#39; p&lt;-pmeasyr::noyau_pmeasyr(finess = 750712184, annee = 2021, mois = 8, path = path_data, tolower_names = TRUE) 4.3 Imports des RSA Type Import 1 Light : Partie fixe 2 Light+ : Partie fixe + stream en ligne (+) actes et das 3 Light++ : Partie fixe + stream en ligne (++) actes, das, typaut um et dpdr des um 4 Standard : Partie fixe + creation des tables actes, das et rsa_um 5 Standard+ : Partie fixe + creation des tables actes, das et rsa_um + stream (+) 6 Standard++ : Partie fixe + creation des tables actes, das et rsa_um + stream (++) Source : pmeasyr-book pmeasyr::adezip(p, liste = c(&quot;rsa&quot;,&quot;tra&quot;), type = &quot;out&quot;) pmeasyr::irsa(p, typi = 4, tolower_names = TRUE ) -&gt; rsa21 4.4 Import des RUM Type Import 1 XLight : Partie fixe 2 Light : Partie fixe + stream en ligne des actes, das et dad 3 Standard : Partie fixe + table actes, das, dad 4 Standard+ : Partie fixe + stream + table actes, das, dad Source : pmeasyr-book pmeasyr::adezip(p, liste = c(&quot;rss&quot;), type = &quot;in&quot;) rum21&lt;- pmeasyr::irum(p, typi = 4, tolower_names = TRUE ) 4.5 Import des fichiers TRA et ANO Le fichier TRA est un fichier du out qui permet de relier les données anonymes du out aux données du in. Il comprend un lien entre : clé rsa, numéro de rss, numéro de sejour (nas), date dentrée date de sortie du séjour Limport se fait en 2 parties : import du fichier avec la fonction itra, ajout des colonnes dans la table des rsa inner_tra . Le fichier ANO contient les données de lANOHSP, on utilise ici les ano du out auquel il faut ajouter également les élements du TRA. pmeasyr::itra(p) -&gt; tra pmeasyr::iano_mco(p) -&gt; rsa_ano pmeasyr::inner_tra(rsa15$rsa, tra) -&gt; rsa15$rsa pmeasyr::inner_tra(rsa_ano, tra) -&gt; rsa_ano 4.6 Table pmeasyr des formats Les fonctions dimport de pmeasyr utilisent les formats officiels défini par lATIH pour constituer les fichiers qui seront mis en entrées et sortie des logiciels développés par lagence et qui permettront léchange de données (formats officiels des données en entrée des logiciels permettant la transmission). Cest format sont stockés dans le package sous la forme dun table de format accèssible aux utilisateurs pmeasyr::formats pmeasyr::formats %&gt;% View() La fonction View() permet daccéder à un visionneur de code Liste des variables pour la table RSA en 2021 pmeasyr::formats %&gt;% dplyr::filter(table == rsa, an == 21) Le TRA dans les différents champs et les différentes années Remarquez lutilisation de la fonction dplyr::n() qui permet de compter le nombre de ligne dans un dataframe pmeasyr::formats %&gt;% dplyr::filter(table == &quot;tra&quot;) %&gt;% dplyr::group_by(champ,an) %&gt;% dplyr::summarise(nb = dplyr::n() ) %&gt;% View() Nombre dannées disponibles pour chaucn des champs avec visablisation du noms des tables importables Pour compter le nombre déléments distinct dans un vecteur, on utilise les fonctions length() et unique() . #exemple length(unique(x)) x = c(4,4,5,5,5,5,6,6,6) length(x) unique(x) length(unique(x)) Mise en application pour compter le nombre dannées disponibles par champ et par table pmeasyr::formats %&gt;% dplyr::group_by(champ,table) %&gt;% dplyr::summarise(nb_annee = length(unique(an))) %&gt;% View() NB: on voit quun package peut contenir à la fois des fonctions et des jeux de données. Cest le cas ici avec la table formats qui contient des données de parmatrage. 4.6.1 Récupérer des référentiels sur referime Le package referime maintenu par Namik Taright alimente le serveur de référentiels du DIM de lAP-HP. Il est à la base dun webservice utilisé par différents entités de linstitution pour accéder aux référentiels PMSI. Il contient de nombreux fichiers de références utiles pour lanalyse des données PMSI. 4.6.2 Fichier descriptif des UMA sur referime Le fichier AMURM est maintenu par le DIM du siège et comprend de nombreuses données utiles sur les UM. Dans sa forme actuelle il comprend également les UA qui sont le niveau en dessous de lUMA. Dans la mesure où il peut y avoir plusieurs UA par UMA, il peut contenir plusieurs lignes pour une seule UMA. library(referime) amurm21&lt;- referime::get_table(&quot;amurm_2021&quot;) View(amurm21) 4.6.2.1 DMS de la base nationale La colonne anseqta contient linformation sur lannée de version du tarif. Elle comprend : les séjours de lannée n à partir du 1er mars les séjours de lannée n+1 jusquau 28/29 février #dms base nationales dms_nationales &lt;- referime::get_table(&quot;ghm_dms_nationales&quot;) View(dms_nationales) Attention, par construction le calcul des dms sur la base nationale ne peut être en cours dannée, pour lannée en cours on se contente dutiliser les dms calculées sur lannée précédente. Pour cela on utilise la fonction dplyr::bind_rows qui permet de concaténer des dataframes par lignes (sont équivalant par colonne est dplyr::bind_cols ). Exemple dutilisation de #Exemple de fusion de 2 jeux de données qui n&#39;ont pas les mêmes colonnes dplyr::bind_rows( dms_nationales %&gt;% dplyr::filter( anseqta==&quot;2020&quot;, !is.na(ghm) ) %&gt;% dplyr::select( anseqta, dms_n, ghm ), dms_nationales %&gt;% dplyr::filter( anseqta==&quot;2020&quot;, !is.na(ghs), ghs!=&quot;&quot; ) %&gt;% dplyr::select( anseqta, dms_n, ghs ) ) -&gt; test test test %&gt;% dplyr::filter(!is.na(ghm)) test %&gt;% dplyr::filter(!is.na(ghs)) Application pour créer une table de référentiel base nationale complète. #2021 pas encore présente dans le fichier, on utilise 2020 dms_nationales&lt;- dms_nationales %&gt;% dplyr::filter(anseqta==&quot;2020&quot;) %&gt;% dplyr::mutate(anseqta = &quot;2021&quot;) %&gt;% dplyr::bind_rows(dms_nationales,.) NB : les fonctions dplyr sont plus souples que les fonctions natives de R et elles tolèrent que les 2 dataframes naient pas exactement le même nombre de colonnes. Dans ce cas, elles créent des colonnes vides pour les colones qui pouraient manquer dans lun des 2 dataframe. 4.6.2.2 Autres références utiles #Actes CCAM : icr, actes chriurgicaux icr &lt;- referime::get_table(&quot;ccam_icr&quot;) %&gt;% filter(activite == 1) rgp &lt;- referime::get_table(&quot;ccam_regroupement&quot;) %&gt;% filter(activite == 1, regroupement == &quot;ADC&quot;) acte_chir &lt;- rgp %&gt;% select(code) %&gt;% inner_join(icr, by = c(&quot;code&quot;)) cim &lt;- referime::get_table(&quot;cim&quot;) %&gt;% dplyr::distinct(code,.keep_all = TRUE) %&gt;% dplyr::select(code,lib_court) #Regroupements GHM regroupement &lt;- referime::get_table(&#39;ghm_ghm_regroupement&#39;) 4.7 Création dune table contenant la plus part des informations utiles Les données du in et out GENRSA ont chacune leur utilité, mais elles sont en partie redondantes. Afin de mieux sy retrouver nous vous proposons de créer une table pivot constutée par la jointure de plusieurs tables et qui contiendra les principales données utiles pour lanalyse de lactivité. Quelques détails sur les foncitons de jointure ?dplyr::left_join Nous utilsons les fonctions de jointure pour fusionner les tables ano, rsa, rum et amurm sans déclarer les colonnes qui permettront la jointure dans le by. data21 &lt;- rsa_ano %&gt;% dplyr::select(nas,cle_rsa,dtent,dtsort,factam, pbcmu, motnofact, typecont ) %&gt;% dplyr::inner_join( ., rsa21$rsa %&gt;% dplyr::select(cle_rsa,noseqrum,anseqta,ansor,moissor,ghm,noghs,sexe,agean, agejr,echpmsi,prov,schpmsi,dest,nbrum,duree)) data21 &lt;- data21 %&gt;% dplyr::left_join( ., rum21$rum ) Danslce fichier amurm les UMA entité juridique sont dénommées uma_ej alors que dans le nom de cette variable importée avec pmeasyr est cdurm . On change le nom de la variable avant la fusion des tables. Par ailleurs comme on souhaite une seule ligne par UMA on procède à un déboulonnage. On utilise ici la fonction dplyr::distinct amurm21 %&gt;% dplyr::rename(cdurm = uma_ej) %&gt;% View() Ecrite comme cela lensemble des colonnes de la table sont supprimées. On ajoute .keep_all = T amurm21 %&gt;% dplyr::rename(cdurm = uma_ej) %&gt;% dplyr::distinct(cdurm,.keep_all = T) %&gt;% View() On utilise cette nouvelle table dans la jointure, en ne slectionnant que les colonnes qui nous interessent data21 &lt;- data21 %&gt;% dplyr::left_join( ., amurm21 %&gt;% dplyr::rename(cdurm = uma_ej) %&gt;% dplyr::distinct(cdurm,.keep_all = T) %&gt;% dplyr::select( gh, cdurm, typaut, mode_hospit, nohop, lib_hop,lib_cc9_uma,spe_uma,lib_spe_uma) ) Ajout des dms dans la base nationale : Attention jointure complexe car les dms de la base nationale sont préférentiellement calculées au niveau GHS mais dans certain cas également au niveau GHM (soins pallialits par exemple). Enfin les DMS ne sont pas calculées pour tous les GHM (séances par exemple). Au final on procède en 3 étapes : table intermédaire 1 résultat de lappariement des rum avec la table de référence sur le GHM table intermédaire 2 résultat de lappariement des rum avec la table de référence sur le GHS ajout des séjours nappartenant à aucune des 2 tables ci dessus #ajout d&#39;une indicatrice pour repréer les lignes de la table iniatale data21&lt;- data21 %&gt;% dplyr::mutate(id = 1:nrow(data21)) #Merge rsa, dms pour les cas ou la référence dans ghm_dms_nationales = ghm data21_dms1&lt;- dplyr::inner_join(data21 %&gt;% dplyr::rename(ghs = noghs), dms_nationales %&gt;% dplyr::filter(ghs!=&quot;&quot;, !is.na(ghs)) %&gt;% dplyr::distinct(anseqta,ghs,.keep_all = T) ) #Merge rsa, dms pour les cas ou la référence dans ghm_dms_nationales = ghm data21_dms2&lt;-inner_join(data21%&gt;%rename(ghs = noghs), dms_nationales%&gt;%filter(ghs==&quot;&quot;) %&gt;% dplyr::select(-ghs) %&gt;% dplyr::distinct(anseqta,ghm,.keep_all = T) ) data21_2 &lt;- dplyr::bind_rows(data21_dms1,data21_dms2) data21 &lt;- dplyr::bind_rows(data21_2, data21 %&gt;% dplyr::filter(! id %in% c(data21_dms1$id,data21_dms2$id) ) ) rm(data21_dms1,data21_dms2,data21_2) *** Au final *** le dataframe data21 contient une ligne par RUM. Il comprend également des données utiles retrouvées dans la table de description des UMA, de lANO et des RSA. Il peut être utiliser pour réaliser de nombreux calcul utiles comme nous allons le voir dans les chapitres suivants. "],["pmeasyr-imports-mco-dans-une-base-de-données.html", "5 pmeasyr : Imports MCO dans une base de données", " 5 pmeasyr : Imports MCO dans une base de données Les données PMSI étant par nature volumineuses, il est parfois difficile de travailler avec des logiciels tels que R qui stockent les données dans la mémoire RAM de la machine. Une solution est dutiliser des logiciels de bases de données qui permettent de stocker les données sur le disque dur et offre des solutions de requêtage optimiséees. Il existent de nombreux logiciels de gestion de bases de données, dont certains sont à la fois très simples à installer un ordinateur de bureau et facilement interfaçable avec R. Nous verrons dans ce chapitre une des solutions possibles (duckdb)[https://duckdb.org/]. En règle générale ces logiciels utilisent le language de requête SQL. Mais afin de garantir une unité de la programmation avec R, les développeurs de la librarie dplyr ont prévu des interfaces entre R et le language SQL. On peut donc utiliser un de ces logiciels de base de données sans programmer en SQL en utilisant uniquement avec la librarie dplyr . Par ailleurs, le package pmeasyr propose des fonctions qui permettent dimporter les données dans la base de données, ce qui simplifie encore lutilisation pour lanalyse de données PMSI volumineuses. En pratique, on utilise le package DBI, qui permet de se connecter en R à de nombreux logiciels de base de données, et qui est installé par défaut avec dplyr , et la package duckdb qui permet dinstaller directement avec R à la fois lapplication duckdb et le pilote de connexion R qui sera utilisé par DBI. 5.0.1 Installation de la librarie duckdb pour R install.packages(&quot;duckdb&quot;) # Chargement des packages et fonctions utiles library(pmeasyr) library(duckdb) library(referime) Une base duckdb correspond à un fichier unique dont on déclare le chemin 5.0.2 Création dune connexion #Définition du répertoire de travail path_db &lt;- &quot;D:/data/duckdb/pmsi_test.duckdb&quot; #Parametrage de la connexion à la base de données connection_db &lt;- DBI::dbConnect(duckdb::duckdb(), path_db ) 5.0.3 Imports pmeaysr # noyau pmeasyr p &lt;- pmeasyr::noyau_pmeasyr( finess = &#39;750712184&#39;, annee = 2021, mois = 11, path = &#39;D:/data/mco/202111&#39;, progress = F, tolower_names = T, # choix de noms de colonnes minuscules : T / F lib = F) Les fonctions pmeasyr::db_mco_out et pmeasyr::db_mco_in permettent dimporter les principales tables à partir des fichiers de remontée. pmeasyr::db_mco_out(connection_db, p,remove = F, zip = T) pmeasyr::db_mco_in(connection_db, p,remove = F, zip = T) Importer des informations sur les strcutures à partir de referime (tables amurm) struct &lt;- referime::get_table(&quot;amurm_2021&quot;) struct &lt;- struct %&gt;% dplyr::rename(cdurm = uma_ej) %&gt;% dplyr::distinct(cdurm,.keep_all = T) DBI::dbWriteTable(connection_db, &quot;mco_21_ium&quot;,struct ) Visualiser le contenu de la table mco_21_rsa_rsa an = 21 dplyr::tbl(connection_db, &quot;mco_&quot; %+% an %+% &quot;_rsa_rsa&quot;) Pour linstant les données restent dans la base de données et ne sont pas importer dans la mémoire comme traditionnellement en R. Les opération classique en SQL sont possible: - sélection des colonnes (clause SELECT en SQL) avec dplyr::select - appliquer des critères de sélection sur les données (clause WHERE en SQL) avec dplyr::filter - réaliser des jointure entre les tables (fonction JOIN en SQL) avec dplyr::inner_join , dplyr::left_join,dplyr::right_join,dplyr::full_join Exemple de requêtes complexe utilisée dans le projet Tableau de bord fluidité des parcours dplyr::tbl(connection_db, &quot;mco_&quot; %+% an %+% &quot;_rsa_ano&quot;) %&gt;% dplyr::select(nas,cle_rsa,dtent,dtsort,factam, pbcmu, motnofact, typecont ) %&gt;% dplyr::inner_join( # any_of parce que les vars d&#39;eligibilite ne sont dans la table que pour 2021 dplyr::tbl(connection_db, &quot;mco_&quot; %+% an %+% &quot;_rsa_rsa&quot;) %&gt;% dplyr::select(any_of(c(&#39;cle_rsa&#39;,&#39;noseqrum&#39;,&#39;anseqta&#39;,&#39;ansor&#39;,&#39;moissor&#39;,&#39;ghm&#39;,&#39;noghs&#39;,&#39;sexe&#39;, &#39;agean&#39;,&#39;agejr&#39;,&#39;echpmsi&#39;,&#39;prov&#39;,&#39;schpmsi&#39;,&#39;dest&#39;,&#39;nbrum&#39;,&#39;duree&#39;,&#39;cdgeo&#39;, &#39;ell_gradation&#39;,&#39;surveillance_particuliere&#39;,&#39;resererve_hosp&#39;,&#39;rescrit_tarifaire&#39;, &#39;cat_nb_intervenants&#39;))) , . ) %&gt;% #type de séjours dplyr::left_join( ., dplyr::tbl( connection_db, &quot;mco_&quot; %+% an %+% &quot;_rum_rum&quot; ) %&gt;% dplyr::left_join(., dplyr::tbl( connection_db, &quot;mco_&quot; %+% an %+% &quot;_ium&quot; ) %&gt;% dplyr::select( gh, cdurm, typaut, mode_hospit, nohop, lib_hop, uma,lib_uma, lib_cc9_uma,spe_uma,lib_spe_uma, ua, lib_ua,lib_cc9_ua, spe_ua, lib_spe_ua, serv,lib_service, pole, lib_pole) ) ) -&gt; query En pratique lensemble de ce code est transcodé en SQL par dplyr et envoyé à la base de données. Pour linstant, il ne sagit que de code SQL qui sont testés sur la base duckdb mais qui ne sont pas importées. Afin de faire des calcul plus complexes, nous devons importer les données dans R, cette opération est réalisée avec la fonction dplyr::collect . Une fois an = 21 dplyr::tbl(connection_db, &quot;mco_&quot; %+% an %+% &quot;_rsa_rsa&quot;) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
