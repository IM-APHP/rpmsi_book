[["index.html", "Analyser les données PMSI avec R Bienvenu", " Analyser les données PMSI avec R Rémi Flicoteaux Bienvenu Les premiers chapitres du livre sont une compiltation/traduction de livres numériques que nous vous conseillons de lire pour aller plus loin : R for Data Science Advanced R Traitement des données PMSI avec R "],["introduction.html", "1 Introduction 1.1 Les notions et concepts que vous aller acquérir", " 1 Introduction R est un langage de programmation ce qui signifie qu’il est une interface entre des instructions données par un utilisateur, dans une forme écrite, et les capacités de calcul de l’ordinateur. Ces capacités sont très grandes dès lors que les instructions qui lui sont données peuvent être exécutées sans erreur, et c’est bien l’art de la programmation qui est de réussir à utiliser ces fonctionnalités sans erreur. L’idée qui sous tend la création des langages tels que R est de simplifier le plus possible ces interactions, de façon à simplifier la vie des utilisateurs. L’informatique peut permettre de résoudre de nombreux problèmes et R est un langage spécialisé dans le calcul statistique. Ces dernières années, la perception de cette discipline a beaucoup évolué et en particulier avec l’avènement d’une vision peut être plus globale que le calcul statistique lui-même, celle de la science des données, qui inclut également de nombreuses étapes de traitement et préparation des données elles-mêmes et qui sont un préalable au calcul à proprement parler. R a suivi ces évolutions avec le développement de package spécifiques qui sont venus enrichir l’architecture de base du langage et qui proposent une nouvelle façon d’écrire le code très influencée par l’idée que chaque projet est en fait l’exécution de tâches élémentaires successives qui s’enchaînent sous la forme d’une chaîne de traitement. Nous allons voir dans les premiers chapitres de ce livre les éléments de base du langage et comment ces nouvelles méthodes de programmation peuvent être particulièrement adaptées à l’analyse des données PMSI. Cette introduction à la programmation en R qui se veut la plus pragmatique possible, est exclusivement orienté vers l’analyse des données PMSI de façon à faire de R un de vos outils de travail directement opérationnel. Elle ne doit pas faire perdre de vue que toute personne qui souhaitera à l’issue de cette introduction s’engager dans l’utilisation de R sur le long terme, devra approfondir sa connaissance du langage afin de devenir complètement autonome. La chance est qu’il existe 2 ouvrages de références qui vont permettront d’acquérir ces compétences : - R for Data Science - Advanced R La lecture de ces livres nous apparaît indispensable et loin d’être insurmontable au contraire. Cette introduction à R a pour objectif de vous donner l’envie d’aller plus loin. 1.1 Les notions et concepts que vous aller acquérir R est un language de programmation, ce qui veut dire que vous allez faire de la programmation. Que cela n’inquiètes pas trop ceux qui n’en ont pas l’habitude, c’est au final assez simple. R est un langage de programmation, ce qui veut dire que vous allez faire de la programmation. Que cela n’inquiète pas trop ceux qui n’en ont pas l’habitude, c’est au final assez simple. On peut classiquement séparer en 4 les étapes d’un projet d’analyse des données PMSI : 1- Importer les données. Pour nous cela repose essentiellement par l’utilisation du package pmeasyr, qui permet d’importer les fichiers officiels en entrée et sortie du logiciel GENRSA et qui sont donc utilisés par les établissements pour la transmission des données à l’ATIH. Il est souvent nécessaire pour bien exploiter les données PMSI d’utiliser des référentiels (CIM, CCAM, GHM,…). La plupart des référentiels utiles sont regroupés dans le package referime.Néanmoins d’autres types de données peuvent vous êtes utiles et nous couvrirons également le sujets de l’import des données dans d’autres format. 2- Préparer et transformer des données brute afin par exemple de créer de nouvelle variables qui nous permettent de répondre aux questions posées. 3- L’analyse de données elles-mêmes. Dans le cadre des projets PMSI c’est souvent la sélections de séjours et la réalisation de statistiques descriptives. Certains projets plus complexes nécessitent de faire de la modélisation. 4- Enfin, nous avons besoin de communiquer des résultats sous forme de données tabulées et de représentations graphiques. Ce livre a pour objectif de vous donner les bases qui vous permettrons de réaliser ces 4 étapes. "],["language-r-les-fondamentaux.html", "2 Language R : les fondamentaux 2.1 Instructions 2.2 Objets 2.3 Fonctions 2.4 Le format des objets 2.5 La grammaire dplyr", " 2 Language R : les fondamentaux 2.1 Instructions R en tant que langage interprété (en opposition à un langage compilé) peut être utilisé pour envoyer des instructions qui sont exécutées directement par la machine. Il existe donc un interpréteur R que l’on peut utiliser tel quel, par exemple comme une machine à calculer. 1 / 200 * 30 ## [1] 0.15 (59 + 73 + 2) / 3 ## [1] 44.66667 sin(pi / 2) ## [1] 1 1:10 ## [1] 1 2 3 4 5 6 7 8 9 10 Dès lors que nos instructions vont se complexifier on voit qu’il sera utile de garder la trace de nos actions et c’est la raison pour laquelle R s’utilise avec un éditeur de code qui permet de sauvegarder l’ensemble des instructions données à la machine. Celles-ci pourront ensuite être envoyées en une seule fois, voire s’exécuter automatiquement avec l’utilisation d’un planificateur de tâches. RStudio propose un environnement de travail intégré qui permet de réunir ces 2 fonctions principales : interpréteur et éditeur de code. Cette intégration permet d’envoyer simplement le code écrit dans l’éditeur à l’interpréteur. C’est cette dernière façon d’écrire du code que nous allons utiliser et qui va nous permettre d’utiliser les programmes préparés pour cette introduction. 2.2 Objets En complément de l’exécution d’instruction, R permet de stocker des données dans la mémoire de l’ordinateur. Pour cela R, n’utilise que la mémoire RAM, la mémoire de travail. Ce principe permet de garantir une exécution rapide des instructions qui utilise les données enregistrées en mémoire, à l’inverse il s’agit d’une mémoire dont la taille est limitée et qui rend donc l’utilisation du langage R plus complexe pour le traitement de données volumineuses. Dans le cadre du traitement des données PMSI, nous pourrons utiliser un autre mode d’enregistrement des données que nous décrirons plus loin dans le livre. En R, toute donnée stockée en mémoire est appelée un objet. Tous les objets ont 2 caractéristiques : un nom qui permet de les retrouver simplement un type qui permet de structurer la façon dont les données sont stockées. Il existe plusieurs types d’objets en R dont la définition et la formalisation informatique constituent le cœur du langage. Cela peut être des nombres, des données plus complexes rangées dans des vecteurs ou des tableaux de données (datadrame) qui sont un équivalent de feuille de calcul excel avec des lignes et des colonnes, mais aussi des instructions, organisées dans une fonction. Il existe d’autres types d’objets qui permettent de donner au langage puissance et souplesse. Parmi eux, nous mentionnons les listes qui sont très pratique et qui sont une collection d’objets qui peuvent avoir des types différents rangés une même entité. On peut créer de nouveaux objets avec l’instruction &lt;-: x &lt;- 3 * 4 x ## [1] 12 Toutes les instructions (statements) qui permettent de créer des objets (assignment statements) sont de la forme : nom_objet &lt;- value Le signe = fonctionne également, mais il est quelque peu trompeur et il est communément admis que pour bien marqué le fait qu’il s’agit de donner un nom à un objet stocké en mémoire, on préfère utiliser &lt;- . 2.3 Fonctions L’ensemble du langage R tient donc sur ce paradigme de nom et de type d’objets et sur le fait que les objets sont accessibles par leur nom. Les fonctions constituent un type d’objets à part. Dans la mesure où, en règle générale, elles reçoivent des arguments sur lesquels on va appliquer des transformations, elle s’appelle avec des parenthèses. function_name(arg1 = val1, arg2 = val2, ...) Il n’en reste pas moins qu’elles sont des objets, stockées en mémoire, accessibles à tout moment par leur nom, lorsqu’elles sont appelées, elles réalisent l’ensemble des instructions qu’elles contiennent et renvoie leur résultat. mean(x) Les fonctions de base dont dispose le langage R sont organisées sous forme de packages. En règle générale, elles ne sont accessibles par leur nom que si nous avons demandé le chargement du package. Ce chargement a pour conséquence de placer dans l’environnement de travail le nom de l’ensemble des fonctions d’un package. Le package qui contient le langage lui-même s’appelle base. Il est en grande partie constituée de fonctions écrites en C qui constituent l’apport du langage lui-même. Il est par défaut chargé en mémoire et les fonctions du package peuvent donc être utilisées sans chargement préalable comme nous l’avons vu avec l’exemple du calcul de la moyenne. Les fonctions des différents packages peuvent néanmoins être appelées directement dès lors que l’on référence dans l’appel le nom du package : pmeasyr::irsa(p) Cette fonction du package pmeasyr permet de réalisé l’import des RSA dans R. Avant de réaliser concrètement cet import, voyons plus en détails comment s’ organise l’enregistrement des données. 2.4 Le format des objets Chaque donnée possède un format de base qui permet de stocker l’information. R distingue 5 types de données : caractère entiers nombre (réel ou décimal) les nombres complexes une variable logique oui/non Il en existe en réalité une 6ème forme qui ne sera pas abordée ici. Avec ces différentes formes on peut constuituer d’autres types de données unitaires en particulier : les dates et datatime qui sont en réalité stockées sous forme numérique qui constue l’écart par rapport à un référentiel (par exemple le nombre de jour qui sépare la date du jour du 1er janvier 1970) les facteurs Nous approfondirons ces différentes types au cours du livre. Le niveau suivant le vecteur qui correspond vraiment au cœur du langage. L’instruction : permet de créer facilement des séquences : x&lt;- 1:10 Ils sont bien sur constitués par un ensemble de données élémentaires d’un certain type. Un vecteur n’est donc constitué que d’un seul type de données. Cela permet en particulier de garantir que des opération numérique pourront être réalisée d’un bloc sur un vecteur, par exemple une addition : x+5 ## [1] 6 7 8 9 10 11 12 13 14 15 On voit que le chiffre 5 a été ajouté à l’ensemble des éléments du vecteur en une seule instruction. Le calcul est vectorisé c’est ce qui fait la grande force de R et qui assure à la fois une simplicité d’écriture (pas de boucle à écrire) et une rapidité d’exécution (l’ensemble du détail du calcul a été programmé en C avec le maximum d’efficacité). En fait, le niveau de base des objets R sont des vecteurs de données élémentaires et il n’existe pas à proprement parler d’objet vecteur dont on pourrait tester le type. Nous indiquons des fonctions qui permettent d’avoir d’obtenir des information sur la nature des objets. str(x) ## int [1:10] 1 2 3 4 5 6 7 8 9 10 class(x) ## [1] &quot;integer&quot; typeof(x) ## [1] &quot;integer&quot; La taille du vecteur : length(x) ## [1] 10 Ces vecteurs peuvent ensuite être associé en tableau de données (dataframe) qui seront les éléments les plus utilisés pour l’analyse de données PMSI. x &lt;- data.frame(x= 1:10, y= 21:30) Il s’agit en fait d’une collection de vecteurs. str(x) ## &#39;data.frame&#39;: 10 obs. of 2 variables: ## $ x: int 1 2 3 4 5 6 7 8 9 10 ## $ y: int 21 22 23 24 25 26 27 28 29 30 class(x) ## [1] &quot;data.frame&quot; typeof(x) ## [1] &quot;list&quot; Les données de base unitaires sont accessibles par l’utilisation des crochets en identifiants les “coordonnées” dans le tableau, position de ligne et de colonne : line_number = 1 columun_number = 2 x[line_number , columun_number] ## [1] 21 Les dataframe ont des noms de colonnes et des noms de ligne names(x) ## [1] &quot;x&quot; &quot;y&quot; row.names(x) ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; &quot;4&quot; &quot;5&quot; &quot;6&quot; &quot;7&quot; &quot;8&quot; &quot;9&quot; &quot;10&quot; Les données de base unitaires sont également accessibles en identifiant les noms de lignes et de colonnes qui sont de type caractère et non numérique : line_name = &quot;1&quot; columun_name = &quot;x&quot; x[line_name , columun_name] ## [1] 1 Enfin, on peut également identifier une colonne entière par l’utilisation du symbole $. x$x ## [1] 1 2 3 4 5 6 7 8 9 10 Comme un dataframe est une collection de vecteur, les colonnes des dataframes partagent les mêmes caractéristiques, et en particulier elles ne sont constituées que d’une seule catégorie de données. On peut par ailleurs utiliser le calcul vectoriel : x$x + 5 ## [1] 6 7 8 9 10 11 12 13 14 15 On pourrait développer les nombreuses actions qui peuvent réalisée avec les dataframe dans le paradigme historique du langage R. Nous allons néamoins faire un saut pour se concentrer directement sur les nouvelles méthodes de manipulation des objets en R dans le paradigme tidyverse qui propose un ensemble de packages permettant de faciliter l’analyse de données. 2.5 La grammaire dplyr En premier lieu, nous introduisons une fontion particulière qui a pour but de tenir compte du fait que l’on doit en pratique rarement n’utiliser qu’une seule instruction, et qu’a l’inverse on enchaine les instructions sur un même objet, qui se transforme à chaque étape. Cette opérateur qui va vous sembler atypique au premier abord, va rapidement devenir votre meilleur ami. Il a été introduit dans le package magrittr, chargeons le dans l’environement de travail de façon à `%&gt;%` &lt;- magrittr::`%&gt;%` L’opérateur pipe permet donc d’enchainter les instructions, ci dessous deux instruction équivalentes : x + 5 -3 ## x y ## 1 3 23 ## 2 4 24 ## 3 5 25 ## 4 6 26 ## 5 7 27 ## 6 8 28 ## 7 9 29 ## 8 10 30 ## 9 11 31 ## 10 12 32 x %&gt;% + 5 %&gt;% -3 ## x y ## 1 3 23 ## 2 4 24 ## 3 5 25 ## 4 6 26 ## 5 7 27 ## 6 8 28 ## 7 9 29 ## 8 10 30 ## 9 11 31 ## 10 12 32 Le second élément, est la conceptualisation, proposée par le package dplyr, des différentes étapes clés de l’analyse de données dans un paradigme qui ressemble au langage sql et que vous connaissez peut être. Ces principales étapes sont : select : pour sélectionner les colonnes des dataframes filter : pour filtrer les données mutate : qui n’existe pas en sql, et qui permet de modifier les colonnes d’un dataframe. join : pour réaliser les jointures entre dataframe group_by : pour réaliser des regroupements summarise: qui permet de faire des comptes sur l’ensemble des données, par exemple compter le nombre de lignes, cette calculs tenant compte des différents niveau déclarés dans le group_by. Pour tester ces différentes fonction, commençons par charger des données PMSI avec le package pmeasyr. "],["premiers-pas-avec-les-données-pmsi-importées-avec-pmeasyr.html", "3 Premiers pas avec les données PMSI importées avec pmeasyr 3.1 Import des données MCO 3.2 Premières analyses", " 3 Premiers pas avec les données PMSI importées avec pmeasyr 3.1 Import des données MCO La première étape de choisir un répertoire de travail et d’enregistrer vos fichiers de remontées dans ce répertoire. Nosu prendrons ici les recommandations de Guillaume : '~/Documents/data/mco . Les noms des fichiers en sortie de GENRSA sont de la forme : finess.annee.mois.date_et_heure_de_creation.in.zip finess.annee.mois.date_et_heure_de_creation.out.zip Ensuite on dézippe l’archive avec la fonction adzip : pmeasyr::adezip(finess = 750712184, annee = 2021, mois = 8, path = &#39;C:/Users/3056269/Documents/data/mco&#39;, liste = c(&quot;rss&quot;), type = &quot;in&quot;) Import des rsa : pmeasyr::irum(finess = 750712184, annee = 2021, mois = 8, path = &#39;C:/Users/3056269/Documents/data/mco&#39;, typi = 4, tolower_names = TRUE ) -&gt; rum21 L’import a créé plusiseurs dataframe qui sont rangé dans l’objet rsa21 qui est une liste : typeof(rum21) names(rum21) 3.2 Premières analyses Dans cette première partie nous allons tester différents calcul sur les RSA avec le formalisme de dplyr. Commençons par charger le package de façon à ne pas avoir à repéter le préfix dplyr:: : library(dplyr) Sélectionner les rum dont le diagnostic est I10 : rum21$rum %&gt;% filter(dp == &quot;I10&quot;) Sélectionner les rum dont le diagnostic est I10 et changer le format de la date pour avoir le mois de sortie. rum21$rum %&gt;% filter(dp == &quot;I10&quot;) %&gt;% mutate(moissor = format(d8soue,&quot;%m&quot;) ) On peut donc changer le format d’une date en R avec la fonction format. Ci dessus les principaux type de format utilisés. Sélectionner les rum dont le diagnostic est I10 et compter le nombre de résumé par mois, fonction n() permet de compte le nombre de ligne dans le tableau de données, ici groupé par mois : rum21$rum %&gt;% filter(dp == &quot;I10&quot;) %&gt;% mutate(moissor = format(d8soue,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = n()) Créer une table qui permette d’avoir la date d’entrée et de sortie du séjour : dates_sejours &lt;- rum21$rum %&gt;% group_by(nas) %&gt;% summarise(dtentr = min(d8eeue), dtsor = max(d8soue)) %&gt;% ungroup() dates_sejours Réaliser la jointure entre les RUM et les dates d’entrée/sortie du séjours pour faire un calcul du nombre de RUM par mois de sortie du séjour : rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot;) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = n()) Par défaut, la jointure est réalisée sur les colonnes qui sont présentes dans les 2 dataframes : Ne compter que les séjours et non les RUM : rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot;) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = length(unique(nas))) Rechercher le diagnostic dans l’ensemble des diagnostics : 1) Rechercher le diagnostic dans les diagnostics associés rum21$das %&gt;% dplyr::filter(das == &quot;I10&quot;) -&gt; das_i10 utiliser ce résultat pour compléter la recherche rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot; | nas %in% das_i10$nas ) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = length(unique(nas))) Faire la même recherche pour les patients qui résident à Paris : rum21$rum %&gt;% dplyr::filter(dp == &quot;I10&quot; | nas %in% das_i10$nas, substr(cdresi,1,2) == &quot;75&quot; ) %&gt;% left_join(.,dates_sejours) %&gt;% mutate(moissor = format(dtsor,&quot;%m&quot;) ) %&gt;% group_by(moissor) %&gt;% summarise(nb = length(unique(nas))) "],["pmeasyr-imports-mco.html", "4 pmeasyr : Imports MCO 4.1 Les différents fichiers à importer 4.2 Noyau pmeasyr 4.3 Imports des RSA 4.4 Import des RUM 4.5 Import du fichier TRA 4.6 Création d’une table contenant la plus part des informations utiles", " 4 pmeasyr : Imports MCO pmeasyrr-book) 4.1 Les différents fichiers à importer Nom Fonction irsa ~ MCO - Import des RSA irum ~ MCO - Import des RUM idiap ~ MCO - Import des DIAP idmi_mco ~ MCO - Import des DMI iium ~ MCO - Import des donnees UM ileg_mco ~ MCO - Import des erreurs Leg imed_mco ~ MCO - Import des Med ipo ~ MCO - Import des PO iano_mco ~ MCO - Import des Anohosp 4.2 Noyau pmeasyr Comme les différents paramaères de l’import que nous avons vu au chapitre précéndents sont réutilisés plusieurs fois, nous pouvons créer un objet pmeasyr destiné à stocker toutes ces informarions, appelé, noyau : p&lt;-pmeasyr::noyau_pmeasyr(finess = 750712184, annee = 2021, mois = 8, path = &#39;C:/Users/3056269/Documents/data/mco&#39;) 4.3 Imports des RSA Type Import 1 Light : Partie fixe 2 Light+ : Partie fixe + stream en ligne (+) actes et das 3 Light++ : Partie fixe + stream en ligne (++) actes, das, typaut um et dpdr des um 4 Standard : Partie fixe + creation des tables actes, das et rsa_um 5 Standard+ : Partie fixe + creation des tables actes, das et rsa_um + stream (+) 6 Standard++ : Partie fixe + creation des tables actes, das et rsa_um + stream (++) ira(p, typi = 4, tolower_names = TRUE ) -&gt; rsa21 4.4 Import des RUM Type Import 1 XLight : Partie fixe 2 Light : Partie fixe + stream en ligne des actes, das et dad 3 Standard : Partie fixe + table actes, das, dad 4 Standard+ : Partie fixe + stream + table actes, das, dad rum21&lt;- irum(p, typi = 4, tolower_names = TRUE ) 4.5 Import du fichier TRA Le fichier TRA est un fichier du out qui permet de relier les données anonymes du out aux données du in. Il comprend un lien entre : - clé rsa, - numéro de rss, - numéro de sejour (nas), - date d’entrée - date de sortie du séjour L’import se fait en 2 parties : import du fichier avec la fonction itra, ajout des colonnes dans la table des rsa inner_tra . itra(p) -&gt; tra inner_tra(rsa15$rsa, tra) -&gt; rsa15$rsa 4.5.1 Récupérer des référentiels sur referime Le package referime maintenu par Namik Taright alimente le serveur de référentiels du DIM de l’AP-HP. Il est la base d’un webservice utilisé par différents entité de l’institution pour accéder aux référentiels PMSI. Il contient de nombreux fichiers de références utiles pour l’analyse des données PMSI. 4.5.2 Fichier descriptif des UMA sur referime Le fichier AMURM est maintenu par le DIM du siège et comprend de nombreuses données utiles sur les UM. Dans sa forme actuelle il comprend également les UA qui sont le niveau en dessous de l’UMA. Dans la mesure où il peut y avoir plusieurs UA par UMA, il peut contenir plusieur ligne pour une seule UMA. Dans ce fichier les UMA entité juridique sont dénommées uma_ej alors que dans le nom de cette variable importée avec pmeasyr est cdurm . library(referime) ium&lt;- referime::get_table(&quot;amurm_2021&quot;) ium &lt;- ium %&gt;% dplyr::rename(cdurm = uma_ej) %&gt;% dplyr::distinct(cdurm,.keep_all = T) 4.5.2.1 DMS de la base nationale La colonne anseqta contient l’information sur l’année de version du tarif. Elle comprend : les séjours de l’année n à partir du 1er mars les séjours de l’année n+1 jusqu’au 28/29 février Attention, par construction le calcul des dms sur la base nationale ne peut être en cours d’année, pour l’année en cours on se contente d’utiliser les dms calculées sur l’année précédente. #dms base nationales dms_nationales &lt;- referime::get_table(&quot;ghm_dms_nationales&quot;) #2021 pas encore présente dans le fichier, on utilise 2020 dms_nationales&lt;- dms_nationales %&gt;% dplyr::filter(anseqta==&quot;2020&quot;) %&gt;% dplyr::mutate(anseqta = &quot;2021&quot;) %&gt;% dplyr::bind_rows(dms_nationales,.) 4.5.2.2 Autres références utiles #Actes CCAM : icr, actes chriurgicaux icr &lt;- referime::get_table(&quot;ccam_icr&quot;) %&gt;% filter(activite == 1) rgp &lt;- referime::get_table(&quot;ccam_regroupement&quot;) %&gt;% filter(activite == 1, regroupement == &quot;ADC&quot;) acte_chir &lt;- rgp %&gt;% select(code) %&gt;% inner_join(icr, by = c(&quot;code&quot;)) cim &lt;- referime::get_table(&quot;cim&quot;) %&gt;% dplyr::distinct(code,.keep_all = TRUE) %&gt;% dplyr::select(code,lib_court) #Regroupements GHM regroupement &lt;- referime::get_table(&#39;ghm_ghm_regroupement&#39;) 4.6 Création d’une table contenant la plus part des informations utiles Les données du in et out GENRSA ont chacune leur utilité, mais elles sont en partie redondantes. Afin de mieux s’y retrouver nous vous proposons de créer une table pivot constutées par la jointure de plusieurs tables et qui contiendra les principales données utiles pour l’analyse de l’activité. data21 &lt;- rsa21$ano %&gt;% dplyr::select(nas,cle_rsa,dtent,dtsort,factam, pbcmu, motnofact, typecont ) %&gt;% dplyr::inner_join( ., rsa21$rsa %&gt;% dplyr::select(cle_rsa,noseqrum,anseqta,ansor,moissor,ghm,noghs,sexe,agean, agejr,echpmsi,prov,schpmsi,dest,nbrum,duree)) data21 &lt;- data21 %&gt;% dplyr::left_join( ., rum21$rum ) data21 &lt;- data21 %&gt;% dplyr::left_join( ., amurm21 %&gt;% select( gh, cdurm, typaut, mode_hospit, nohop, lib_hop,lib_cc9_uma,spe_uma,lib_spe_uma) ) Ajout des dms dans la base nationale. Attention jointure complexe : les dms de la base nationale sont préférentiellement calculées au niveau GHS mais dans certain cas on préfèrera le niveau GHM (soins palialits par exemple). Enfin les DMS ne sont pas calculées pour tous les GHM (séances par exemple). Au final on procède en 3 étapes - table intermédaire 1 résultat de l’appariement des rum au GHM - table intermédaire 2 résultat de l’appariement des rum au GHS - ajout des séjours n’appartenant à aucune des 2 tables ci dessus data21&lt;- data21 %&gt;% mutate(id = 1:nrow(df)) data21_dms1&lt;-inner_join(data21 %&gt;% rename(ghs = noghs), dms_nationales%&gt;%filter(ghs!=&quot;&quot;) %&gt;% dplyr::distinct(anseqta,ghs,.keep_all = T) ) #Merge rsa, dms pour les cas ou la référence dans ghm_dms_nationales = ghm data21_dms2&lt;-inner_join(data21%&gt;%rename(ghs = noghs), dms_nationales%&gt;%filter(ghs==&quot;&quot;) %&gt;% dplyr::select(-ghs) %&gt;% dplyr::distinct(anseqta,ghm,.keep_all = T) ) data21_2 &lt;- dplyr::bind_rows(data21_dms1,data21_dms2) data21 &lt;- dplyr::bind_rows(data21_2, data21 %&gt;% dplyr::filter(! id %in% c(data21_dms1$id,data21_dms2$id) ) ) rm(data21_dms1,data21_dms2,data21_2) "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
